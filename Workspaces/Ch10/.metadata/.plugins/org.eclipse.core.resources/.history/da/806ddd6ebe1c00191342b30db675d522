/**
 * This is a program where you play a game in which you must attempt to eliminate all the blocks from the screen by clicking on blocks that have same colored neighbors around them.
 * Ben Gutierrez
 */
import acm.program.GraphicsProgram;

import java.awt.Color;
import java.awt.Font;
import java.awt.Label;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Random;

public class Gameboard extends GraphicsProgram {
	Random rand = new Random();
	//Array to store the blocks that are in the game. This helps to keep track of the location of each block in relationship to its neighbors
	GBlock[][] Board = new GBlock[10][10];
	//This is a list that helps to check if a clicked block has neighbors of the same color
	ArrayList<GBlock> blocksToReview = new ArrayList<>();
	
	/** This is the function that is executed when the game starts.
	 * It sets the size of the canvas and draws the random blocks on it.
	 * Then it waits for the player to make their move.
	 */
	public void run(){		
		//1. set size of canvas
		setSize(500,570);
		Label instructions1  = new Label("â€ Click on blocks that are surrounded by other blocks of the same color to delete them.");
		Label instructions2  = new Label(" Delete all the blocks to win!");
		add(instructions1, NORTH);
		Font myFont = new Font("Serif",Font.BOLD,18);
		instructions2.setFont(myFont);
		add(instructions2,SOUTH);

		//2. create the board and draw it in canvas
		for(int i=0; i<Board.length; i++) {
			for(int j=0; j<Board[i].length; j++) {			
				Board[i][j] = new GBlock(j*50,i*50,50,50,i,j);
				Board[i][j].setFilled(true);
				Board[i][j].setFillColor(getRandomColor());
				add(Board[i][j]);			
			}
		}
		//3. Set up a listener for the mouse to check for user input
		addMouseListeners();
	}
	
	/** This function is activated when the player clicks his mouse. 
	 * It determines which blocked was clicked, checks if it has same colored neighbors,
	 * and redraws the board after removing the blocks the selected block and same colored
	 * neighbors.
	 */
	public void mouseClicked(MouseEvent e) {
		GBlock selectedBlock = (GBlock) getElementAt(e.getX(), e.getY());
		//check if there was an element in the spot clicked
		if(selectedBlock != null) {
			//find same colored neighbors and mark them for removal
			findSameColoredNeighbors(selectedBlock);
			//recreate board removing blocks marked for removal
			recreateBoard();
		}
	}

	/** This functions checks if the selected block has neighbors of the same color.
	 * If so, it checks each neighbor to see if they also have neighbors of the same color 
	 * and continue to do so until no more same colored neighbors are found.
	 */
	public void findSameColoredNeighbors(GBlock selectedBlock) {
		blocksToReview = new ArrayList<>();
		//check if selected block has same colored neighbors
		reviewMyFourNeighbors(selectedBlock);

		if(!blocksToReview.isEmpty()){
			selectedBlock.toRemove = true;
			for (int i = 0; i<blocksToReview.size(); i++) {
				//Get a block from the array list
				GBlock currentBlock = blocksToReview.get(i);
				currentBlock.toRemove = true;
				reviewMyFourNeighbors(currentBlock);
			}
		}	
	}
	
	/** This function checks the neighbors of selected block to see if they are the same color.
	 */
	public void reviewMyFourNeighbors(GBlock blockToCheck){
		//check if selected block has same colored neighbors
		int row = blockToCheck.rowInArray;
		int column = blockToCheck.columnInArray;
			
		//check block on the top (if exists)
		if (row > 0){
			GBlock topBlock = Board[row-1][column];
			if (topBlock != null){
				if(topBlock.toRemove == false) {
					if(blockToCheck.getFillColor() == topBlock.getFillColor()) {				
						blocksToReview.add(topBlock);
					}				
				}
			}
		}		
		//check block on the bottom (if exists)
		if (row < 9) {
			GBlock bottomBlock = Board[row+1][column];
			if(bottomBlock != null){
				if(bottomBlock.toRemove == false) {
					if(blockToCheck.getFillColor() == bottomBlock.getFillColor()) {
						blocksToReview.add(bottomBlock);
					}
				}
			}
		}	
		//check block on the right (if exists)
		if (column < 9) {
			GBlock rightBlock = Board[row][column+1];
			if(rightBlock != null){
				if(rightBlock.toRemove == false) {
					if(blockToCheck.getFillColor() == rightBlock.getFillColor()) {
						blocksToReview.add(rightBlock);
					}
				}
			}
		}	
		//check block on the left (if exists)
		if (column > 0) {
			GBlock leftBlock = Board[row][column-1];
			if(leftBlock != null){
				if(leftBlock.toRemove == false) {
					if(blockToCheck.getFillColor() == leftBlock.getFillColor()) {
						blocksToReview.add(leftBlock);
					}
				}
			}
		}
	}
	
	/** This function recreates the Board by removing all the blocks marked for removal
	 * then recreates the board using all the remaining blocks
	 */
	public void recreateBoard() {
		GBlock[][] tempBoard = new GBlock[10][10];
		int tempC = 0;
		int tempR = 9;
		//move to a temporary board all the blocks that don't have to be removed starting
		//from the bottom-left
		for(int c=0; c<Board.length; c++) {
			for(int r=Board[c].length-1;r>=0 ; r--){
				if(Board[r][c] != null){
					if(Board[r][c].toRemove == false) {
						tempBoard[tempR][tempC] = Board[r][c];
						tempR--;
					}
				}			
			}
			tempR=9;
			//if the column in tempBoard is totally empty, we do not move to the next column
			if(tempBoard[9][tempC] != null){
				tempC++;
			}
			
		}
		//remove all the blocks from canvas to redraw them
		removeAll();
		//re-populate board with new block arrangement and add to canvas
		for(int i=0; i<Board.length; i++) {
			for(int j=0; j<Board[i].length; j++) {	
				Board[i][j]=tempBoard[i][j];
				if(Board[i][j] != null) {
					Board[i][j].setLocation(j*50, i*50); // set block's new location in canvas
					Board[i][j].setLocationInArray(i, j); // set block's new location in array 
					add(Board[i][j]);	
				}		 
			}
			
		}
		
	}
	
	/** This function generates random colors that are used to color the blocks
	 */
	public Color getRandomColor() {
		int bear = rand.nextInt(5);
		switch(bear){
		case 0: return Color.red;
		case 1: return Color.blue;
		case 2: return Color.yellow;
		case 3: return Color.green;
		default: return Color.orange;
		}
		
	}
}
